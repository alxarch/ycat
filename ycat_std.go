// Code generated by ycat; DO NOT EDIT.
package ycat
const ycatStdLib = "// Usefull functions\n// Completely inefficient :) should be ported to nativeFuncs\nlocal result(input, arr) =\n    if std.isString(input) && std.isArray(arr) then std.join('', arr) else arr\n    ;\n\nlocal has(x, y) = \n    local t = std.type(x);\n    if t == 'array' then\n        std.count(x, y) > 0\n    else if t == 'object' then\n        std.objectHas(x, y)\n    else if t == 'string' then\n        std.length(std.findSubstr(y, x)) > 0\n    else\n        false\n    ;\n\nlocal skipFunc(x) = if std.type(x) == 'function' then x else function(y) y == x;\nlocal trimFunc(cutset) =\n    if std.isString(cutset) then\n        local cs = std.stringChars(cutset);\n        function (c) std.count(cs, c) > 0\n    else if std.isArray(cutset) then\n        function (c) std.count(cutset, c) > 0\n    else if std.isFunction(cutset) then\n        cutset\n    else if std.isObject(cutset) then\n        function (c) std.objectHas(cutset, c)\n    else if std.isNumber(cutset) then\n        function (c) std.codepoint(c) == cutset\n    else\n        function (c) false\n    ;\nstd + {\n    local _ = self\n    , len:: std.length\n    , has:: has\n    , get(obj, key, v=null)::\n        if std.isObject(obj) && std.objectHas(obj, key) then obj[key] else v\n    , sum(arr)::\n        local add(total, n) = total + n;\n        std.foldl(add, arr, 0)\n    , avg(arr)::\n        local n = std.length(arr);\n        if n > 0 then _.sum(arr)/n else 0\n    , skipWhile(pred, arr)::\n        local func = skipFunc(pred);\n        local skip = function(acc, x) {\n            skip:: if acc.skip then func(x) else false,\n            out:: if self.skip then [] else acc.out + [x],\n        };\n        result(arr, std.foldl(skip, arr, {skip:: true, out:: []}).out)\n    , takeWhile(pred, arr)::\n        local func = skipFunc(pred);\n        local take = function(acc, x) {\n            ok:: if acc.ok then func(x) else false,\n            out:: if self.ok then acc.out + [x] else acc.out,\n        };\n        result(arr, std.foldl(take, arr, {ok:: true, out:: []}).out)\n    , indexOf(arr, x)::\n        local fn(y) = x != y;\n        local n = std.length(_.takeWhile(fn, arr));\n        if n == std.length(arr) then -1 else n\n    , not(func):: function(x) if func(x) then false else true\n    , takeUntil(pred, arr):: _.takeWhile(_.not(skipFunc(pred)), arr)\n    , skipUntil(pred, arr):: _.skipWhile(_.not(skipFunc(pred)), arr)\n    , trunc(arr, size):: // Truncate array\n        local sz = std.min(size, std.length(arr));\n        result(arr, std.makeArray(sz, function(i) arr[i]))\n    , rev(arr):: // Reverse array\n        local size = std.length(arr);\n        local n = size - 1;\n        result(arr, std.makeArray(size, function(i) arr[n-i]))\n    , ascii:: {\n        local inRange(min, max) =\n            local _min = std.codepoint(min);\n            local _max = std.codepoint(max);\n            function (c) _min <= std.codepoint(c) && std.codepoint(c) <= _max\n        , isLower:: inRange('a', 'z')\n        , isUpper:: inRange('A', 'Z')\n        , isDigit:: inRange('0', '9')\n        , space:: \" \\n\\t\\r\"\n        , isAlpha(c):: _.ascii.isLower(c) || _.ascii.isUpper(c)\n        , isAlnum(c):: _.ascii.isLower(c) || _.ascii.isUpper(c) || _.ascii.isDigit(c)\n        , isSpace(c):: c == \" \" || c == \"\\n\" || c == \"\\t\" || c == \"\\r\"\n    }\n    , squeeze(s, cutset)::\n        local tr = trimFunc(cutset);\n        local fn(acc, c) =\n            local n = std.length(acc) - 1;\n            if tr(c) && n >= 0 && tr(acc[n]) then\n                acc\n            else\n                acc + [c];\n        local ss = std.foldl(fn, s, []);\n        result(s, ss)\n\n    , normalize(s):: // Trim and consolidate sequential whitespace to ' '\n        local toSpace(c) = if _.ascii.isSpace(c) then ' ' else c;\n        local ls = _.skipWhile(\" \", _.map(toSpace, s));\n        local rs = _.skipWhile(\" \", _.rev(ls));\n        local ss = _.squeeze(_.rev(rs), \" \");\n        result(s, ss)\n\n    , trimLeft(s, cutset=_.ascii.space):: // Trim left side of a string\n        local tr = trimFunc(cutset);\n        _.skipWhile(tr, s)\n\n    , trimRight(s, cutset=_.ascii.space):: // Trim right side of a string\n        local tr = trimFunc(cutset);\n        local rs = _.skipWhile(tr, _.rev(s));\n        local ls = _.rev(rs);\n        result(s, ls)\n    , trim(s, cutset=_.ascii.space):: // Trim both sides of a string\n        local tr = trimFunc(cutset);\n        local rs = _.skipWhile(tr, _.rev(s));\n        local ls = _.skipWhile(tr, _.rev(rs));\n        result(s, ls)\n    , k8s:: {\n        maxNameSize:: 253\n        , trunc(name)::\n            if std.length(name) > _.k8s.maxNameSize then\n                result(name, _.trunc(name, _.k8s.maxNameSize))\n            else\n                name\n        , namespace(res, ns, override=true)::\n            local n = _.k8s.name(ns);\n            if override then\n                res + {metadata: {namespace: n}}\n            else\n                {metadata+: {namespace: n}} + res\n        , name(s):: // convert string to kubernetes name\n            local fn(c) =\n                if _.ascii.isLower(c) then c\n                else if _.ascii.isDigit(c) then c\n                else if _.ascii.isUpper(c) then std.asciiLower(c)\n                else '-';\n            local cs = std.map(fn, s);\n            local rs = _.skipWhile('-', _.rev(cs)); // trim - from end\n            local ls = _.skipUntil(_.ascii.isLower, _.rev(rs)); // trim -,0-9 from start\n            local name = _.squeeze(ls, \"-\"); // squeeze sequential '-'\n            result(s, _.k8s.trunc(name))\n    }\n\n}"
